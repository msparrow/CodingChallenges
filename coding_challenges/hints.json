{
    "1": "Think about how you might quickly look up a number's complement (the number needed to reach the target).\n",
    "2": "Consider how you'd add two numbers on paper, column by column, starting from the rightmost digit.\n",
    "3": "Consider using a sliding window and a data structure that efficiently tracks the most recent occurrence of each character.\n",
    "4": "Think about how you might efficiently find the kth smallest element in a sorted array, and how that might apply to finding the middle element(s) of two sorted arrays.\n",
    "5": "Consider the potential overflow *before* you complete the reversal.\n",
    "6": "Think about the pattern of row indices as the string is processed.  What kind of repeating sequence emerges?\n",
    "7": "Consider how you'd check if a word is a palindrome.\n",
    "8": "Think about the limiting factor when calculating the area of a container.  What happens if you move the shorter of two lines?\n",
    "9": "Consider the subtractive cases explicitly.  They're exceptions, not the rule.\n",
    "10": "Consider sorting the array before you begin your search.\n",
    "11": "Consider sorting the array first.  It might make finding triplets easier.\n",
    "17": "Think about how the number of opening and closing parentheses must relate to each other at any point in a valid string.\n",
    "30": "Think about how much water can accumulate *above* each bar,  considering its left and right neighbors.\n",
    "36": "Think about how you might uniquely represent each word, regardless of the order of its letters.\n",
    "56": "Think about how you'd build up the combinations iteratively, adding one number at a time.  Consider what constraints you need to ensure you don't exceed `k` numbers or go beyond `n`.\n",
    "27": "Consider how backtracking might help explore all possible combinations, and think about how to avoid duplicate combinations efficiently.\n",
    "12": "Think about recursion and how you might build up combinations one digit at a time.\n\n",
    "13": "Think about how you'd solve the 3Sum problem, and then consider how to adapt that approach to handle one more number.\n\n",
    "14": "Think about how you might find the *nth* node from the *beginning* of the list...  but with a twist.\n\n",
    "15": "Think about what happens if you read the string from left to right, and keep track of what you've seen so far.  A certain data structure might be helpful...\n\n",
    "16": "Think about comparing the values at the current node of each list.  Which node should come *next* in the merged list?\n\n",
    "18": "Consider a \"tournament\" style approach.\n\n",
    "19": "Think about how you'd swap the contents of two variables in Python, but instead of contents, you're swapping the pointers.\n\n",
    "20": "Think recursively... and about how you'd reverse a *small* section of the list.\n\n",
    "21": "Consider using two pointers: one to track the current unique element's position, and another to iterate through the array.\n\n",
    "22": "Think about two pointers: one reading, one writing.\n\n",
    "23": "Consider how you might efficiently check if a smaller string is contained within a larger one, perhaps leveraging built-in string methods.\n\n",
    "24": "Think about how you'd perform a binary search, but instead of just returning `False` when the target isn't found, pay close attention to where the search ends.\n\n",
    "25": "Consider using sets to efficiently check for duplicates.\n\n",
    "26": "Think about how you would describe the string aloud.  What are the repeating units you'd naturally focus on?\n\n",
    "28": "Think about how you'd explore all possible subsets of the candidates, but efficiently avoid redundant checks.  Consider the order you process the candidates.\n\n",
    "29": "Consider the array's indices.\n\n",
    "31": "Think about how you'd multiply numbers on paper, using elementary school arithmetic.\n\n",
    "32": "Think about the furthest reachable index at each step.\n\n",
    "33": "Think about how you'd build up permutations one element at a time, starting with an empty list.  Consider the role of recursion.\n\n",
    "34": "Consider the impact of sorting the input list before processing.\n\n",
    "35": "Think about the relationship between the indices of elements before and after a 90-degree clockwise rotation.  Consider swapping elements in layers, working your way inwards.\n\n",
    "37": "Think about how you might efficiently calculate large exponents by breaking them down into smaller, repeated calculations.\n\n",
    "38": "Consider the constraints imposed by placing a queen in a single column.  How can you efficiently explore only placements that don't lead to conflicts?\n\n",
    "39": "Think about how you can represent the placement of queens on a single row, and how that relates to the placement of queens on subsequent rows.\n\n",
    "40": "Think about how you might keep track of the \"best\" sum seen so far, and how the current sum relates to starting a new subarray.\n\n",
    "41": "Think about how you might recursively peel away the outer layers of the matrix.\n\n",
    "42": "Think about working backwards from the goal.\n\n",
    "43": "Think about sorting... by a specific attribute of the intervals.\n\n",
    "44": "Consider how you would merge two overlapping intervals.  Think about the relationship between the `end` of one interval and the `start` of another.\n\n",
    "45": "Think about how you'd find the last element in a list.  How can you adapt that idea to a string split into words?\n\n",
    "46": "Think about how you'd add 1 to a number on paper, starting from the rightmost digit.\n\n",
    "47": "Think about how you'd add two binary numbers by hand, considering carry-overs.\n\n",
    "48": "Consider the properties of perfect squares and how their roots relate to a sequence of numbers.\n\n",
    "49": "Think about how many ways you can reach each step, building up from the bottom.\n\n",
    "50": "Think about how you'd navigate a file system manually,  paying close attention to what happens when you encounter \"..\" and \".\".\n\n",
    "51": "Consider using the matrix itself to store information about which rows and columns need to be zeroed out.  Think about what values you might already have available to indicate that.\n\n",
    "52": "Think about how the optimal solution for transforming a small prefix of `word1` to a small prefix of `word2` might inform the solution for transforming the entire strings.\n\n",
    "53": "Consider how you'd search a sorted *list*.  Can you adapt that approach to a matrix with the given properties?\n\n",
    "54": "Think about using three pointers, one for each color, and how they might \"sweep\" through the array.\n\n",
    "55": "Consider using two pointers and a data structure to efficiently track the frequency of characters.\n\n",
    "57": "Think about how many subsets a set of n elements has, and how you might generate them using bit manipulation.\n\n",
    "58": "Consider how you might explore all possible paths through a graph.\n\n",
    "59": "Think about how you'd iterate through a list and compare adjacent elements.\n\n",
    "60": "Consider how you might efficiently track which values you've already seen.  A simple data structure might be helpful.\n\n",
    "61": "Think about how the sorted nature of the original array might still be exploited, even after rotation.  Consider the relationship between the first and last elements.\n\n",
    "62": "Consider how you might efficiently search a *sorted* array.  Think about dividing the problem in half repeatedly.\n\n",
    "63": "Consider how the rotated array is \"almost\" sorted.  Think about what properties a sorted array possesses that might still hold, even after a rotation.\n\n",
    "64": "Think about using a counter to track how many times you've seen each number.  What's the maximum allowed count?\n\n",
    "65": "Think about the limiting factor when calculating the area of a rectangle.\n\n",
    "66": "Consider the height of a histogram at each column.\n\n",
    "67": "Think about maintaining two separate lists (or pointers to the beginnings of two lists) during your traversal.\n\n",
    "68": "Consider the character frequencies of the two strings.\n\n",
    "69": "Think about working backwards from the end of `nums1`.\n\n",
    "70": "Think about how you might reflect a list.\n\n",
    "71": "Consider the impact of sorting the input array before generating subsets.\n\n",
    "72": "Think recursively.  A single digit can be decoded in one way.  Consider how the decoding of a string depends on the decoding of its prefixes.\n\n",
    "73": "Think about how you'd reverse a *sub-section* of a linked list,  treating the parts before and after that sub-section as fixed boundaries.\n\n",
    "74": "Consider how many ways you can place three dots within the string.\n\n",
    "75": "Think about how you'd visit every node exactly once, ensuring you process the left subtree before the node itself, and the node before the right subtree.\n\n",
    "76": "Think recursively about how you can build a BST from smaller BSTs.  Consider the root node's value and what that implies about the structure of the left and right subtrees.\n\n",
    "77": "Think about how choosing a root node affects the number of possible left and right subtrees.\n\n",
    "78": "Consider how you might use dynamic programming to track whether a prefix of `s3` can be formed from prefixes of `s1` and `s2`.\n\n",
    "79": "Consider how you might traverse the tree and maintain a range of acceptable values at each step.\n\n",
    "80": "Think about how the inorder traversal of a BST is ordered, and what a single swap would do to that order.  Consider the impact on the sequence of values.\n\n",
    "81": "Consider recursion and a potential base case involving `None`.\n\n",
    "82": "Think recursively, comparing left and right subtrees... but not directly.  Consider the structure of the comparison.\n\n",
    "83": "Consider using a queue.\n\n",
    "84": "Consider how a simple boolean variable might help you alternate between directions.\n\n",
    "85": "Consider how the depth of a subtree relates to the depth of the entire tree.\n\n",
    "86": "Think about how the root node is represented in both preorder and inorder traversals.\n\n",
    "87": "The last element of the postorder traversal is always the root.\n\n",
    "88": "Think about how you'd reverse a list.\n\n",
    "89": "Think about the middle element.\n\n",
    "90": "Consider the list's midpoint.\n\n",
    "91": "Think recursively... and consider what information you need to know about a subtree to determine if *it* is balanced.\n\n",
    "92": "Consider what makes a leaf node special.\n\n",
    "93": "Think about how you might recursively explore all possible paths from the root.  Consider what information needs to be passed down the recursion to keep track of the running sum.\n\n",
    "94": "Think about how you might recursively explore all paths from the root, and what information you'd need to carry along with you as you descend.\n\n",
    "95": "Consider the recursive nature of pre-order traversal and how you might modify the tree's structure during the traversal itself.\n\n",
    "96": "Think about how you'd traverse a tree level by level.  Consider using a queue or, for a particularly clever solution,  a technique that avoids explicit queuing.\n\n",
    "97": "Think about how you'd solve this level-order (breadth-first) if extra space *were* allowed.  Then, consider how you might simulate that process without explicitly using a queue.\n\n",
    "98": "Consider how you might use Depth-First Search (DFS) and keep track of the current number as you traverse the tree.\n\n",
    "99": "Consider using a `set` to efficiently check for the presence of consecutive numbers.\n\n",
    "100": "Think about how you might represent the relationships between words in the dictionary using a graph.\n\n",
    "101": "Consider expanding around the center.\n\n",
    "102": "Think about how the prefix of a string relates to its individual characters, and consider a process that might terminate early.\n\n",
    "103": "Think about how you'd process the string character by character, paying close attention to state transitions.  What conditions might trigger a change in how you interpret subsequent characters?\n\n",
    "104": "Think about recursion, and how you might break down the problem into smaller, self-similar subproblems involving the first character of the string and the first part of the pattern.\n\n",
    "105": "Think about the limiting factor in the area calculation: is it always the shorter line?\n\n",
    "106": "Think about how subtraction works in Roman numerals (e.g., IV, IX).\n\n",
    "107": "Consider the order of the numerals.\n\n",
    "108": "Think about how the prefix of a string relates to its characters at different indices.\n\n",
    "109": "Consider how sorting might help manage duplicates and speed up the search.\n\n",
    "110": "Consider sorting the input array.  Think about how that might simplify finding triplets.\n\n",
    "111": "Consider how sorting might simplify checking for duplicates and finding combinations.\n\n",
    "112": "Think about how you might find the nth node from the *beginning* of the list...  but then adjust your approach slightly.\n\n",
    "113": "Think about using a stack...  and what might naturally go *onto* and *off* of it.\n\n",
    "114": "Consider using a dummy node to simplify handling the head of the merged list.\n\n",
    "115": "Think about how the number of opening and closing parentheses needs to be balanced at every step.\n\n",
    "116": "Consider the efficiency of repeatedly comparing the heads of all remaining lists.\n\n",
    "117": "Think about how you might temporarily store a node's pointer.\n\n",
    "118": "Think recursively, focusing on reversing just the first `k` nodes.  What would the base case be?\n\n",
    "119": "Think about using two pointers: one to track the current unique element's position, and another to iterate through the array.\n\n",
    "120": "Think about using two pointers, one for reading and one for writing.\n\n",
    "121": "Think about how you'd solve this problem if you knew the minimum price seen so far on each day.\n\n",
    "122": "Consider the relationship between the length of a list and the number of unique elements within it.\n\n",
    "123": "Consider the order in which you access the characters.\n\n",
    "124": "Think about how you might efficiently track the *count* of each character.\n\n",
    "125": "Think about how a tortoise and a hare might race around a track.\n\n",
    "126": "Consider how you might serialize a tree into a string.\n\n",
    "127": "Think about how you'd repeatedly halve the search space.\n\n",
    "128": "Consider the effect of repeatedly pairing and removing elements that are different.\n\n",
    "129": "Think about two pointers: one tracking the next non-zero element, and another tracking where to place it.\n\n",
    "130": "Think about the sum of an arithmetic series.\n\n",
    "131": "Consider the efficiency of searching for elements within a set.\n\n",
    "132": "Think about counting things... efficiently.\n\n",
    "133": "Consider the modulo operator (`%`).\n\n",
    "134": "Think about how bitwise XOR behaves with identical numbers.\n\n",
    "135": "Think about how you might efficiently compare the first half of the list to the second half.\n\n",
    "136": "Think about the maximum depth of the left and right subtrees of any node.\n\n",
    "137": "Think recursively...  What's the base case?\n\n",
    "138": "Consider the fundamental properties that distinguish a word from its anagrams.\n\n",
    "139": "Think about how you might leverage the fact that the input array is already sorted.\n\n",
    "140": "Think about only the *differences* between consecutive days.\n\n",
    "141": "Think about working backwards from the end of the arrays.\n\n",
    "142": "Think about how you might build each row from the previous one.  Consider the relationship between elements in adjacent rows.\n\n",
    "143": "Think about how each row is related to the previous row.  Consider the efficiency of recalculating values already known.\n\n",
    "144": "Consider working from right to left.\n\n",
    "145": "Think about how you might efficiently compare the beginning and end of a string, and what data structure might help you ignore irrelevant characters.\n\n",
    "146": "Think about how you might reverse the order of elements within a stack...  and how that might help you achieve FIFO behavior.\n\n",
    "147": "Think about how you can \"rotate\" elements in a queue to get the last added element to the front.\n\n",
    "148": "Think about the binary representation of powers of two.\n\n",
    "149": "Think about the prime factorization of powers of three.\n\n",
    "150": "Consider the binary representation of powers of four.\n\n"
}